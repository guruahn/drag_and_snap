// Generated by CoffeeScript 1.6.2
/*
  Shortcuts for Framer 1.0
  http://github.com/facebook/shortcuts-for-framer

  Copyright (c) 2014, Facebook, Inc.
  All rights reserved.
  
  License:
  http://shortcuts-for-framer.s3.amazonaws.com/LICENSE.txt
*/


/* 
  CONFIGURATION
*/


(function() {
  var Device;

  Framer.config.displayInDevice = {
    enabled: true,
    resizeToFit: true,
    containerView: typeof PSD !== "undefined" && PSD !== null ? PSD.Phone : void 0,
    canvasWidth: 640,
    canvasHeight: 1136,
    deviceWidth: 770,
    deviceHeight: 1610,
    deviceImage: 'http://shortcuts-for-framer.s3.amazonaws.com/iphone-5s-white.png',
    bobbleImage: 'http://shortcuts-for-framer.s3.amazonaws.com/bobble.png'
  };

  Framer.config.defaultAnimation = {
    curve: "spring(700,80,1000)",
    time: 500
  };

  Framer.config.fadeAnimation = {
    curve: "ease-in-out",
    time: 200
  };

  Framer.config.slideAnimation = {
    curve: "ease-in-out",
    time: 200
  };

  /*
    LOOP ON EVERY VIEW
  
    Shorthand for applying a function to every view in the document.
  
    Example:
    ```Framer.utils.everyView(function(view) {
      view.visible = false;
    });```
  */


  Framer.utils.everyView = function(fn) {
    var viewName, _results, _view;

    _results = [];
    for (viewName in PSD) {
      _view = PSD[viewName];
      _results.push(fn(_view));
    }
    return _results;
  };

  /*
    SHORTHAND FOR ACCESSING VIEWS
  
    Convert each view coming from the exporter into a Javascript object for shorthand access.
  
    If you have a layer in your PSD/Sketch called "NewsFeed", this will create a global Javascript variable called "NewsFeed" that you can manipulate with Framer.
  
    Example:
    `NewsFeed.visible = false;`
  
    Notes:
    Javascript has some names reserved for internal function that you can't override (for ex. )
  */


  Framer.utils.everyView(function(view) {
    return window[view.name] = view;
  });

  /*
    FIND CHILD VIEWS BY NAME
    
    Retrieves subviews of selected view that have a matching name.
    
    getChild: return the first subview whose name includes the given string
    getChildren: return all subviews that match
    
    Useful when eg. iterating over table cells. Use getChild to access the button found in each cell. This is **case insensitive**.
    
    Example:
    `topView = NewsFeed.getChild("Top")` Looks for view whose name matches Top. Returns the first matching view.
  
    `childViews = Table.getChildren("Cell")` Returns all children whose name match Cell in an array.
  */


  View.prototype.getChild = function(needle) {
    var found, k, subView;

    for (k in this.subViews) {
      subView = this.subViews[k];
      if (subView.name.toLowerCase().indexOf(needle.toLowerCase()) !== -1) {
        return subView;
      }
    }
    for (k in this.subViews) {
      subView = this.subViews[k];
      found = subView.getChild(needle);
      if (found) {
        return found;
      }
    }
  };

  View.prototype.getChildren = function(needle) {
    var k, results, subView;

    results = [];
    for (k in this.subViews) {
      subView = this.subViews[k];
      results = results.concat(subView.getChildren(needle));
    }
    if (this.name.toLowerCase().indexOf(needle.toLowerCase()) !== -1) {
      results.push(this);
    }
    return results;
  };

  /*
    CONVERT A NUMBER RANGE TO ANOTHER
    
    Converts a number within one range to another range
    
    Example:
    We want to map the opacity of a view to its x location.
    
    The opacity will be 0 if the X coordinate is 0, and it will be 1 if the X coordinate is 640. All the X coordinates in between will result in intermediate values between 0 and 1.
    
    `myView.opacity = convertRange(0, 640, myView.x, 0, 1)`
  */


  Framer.utils.convertRange = function(OldMin, OldMax, OldValue, NewMin, NewMax) {
    var NewRange, OldRange;

    OldRange = OldMax - OldMin;
    NewRange = NewMax - NewMin;
    return (((OldValue - OldMin) * NewRange) / OldRange) + NewMin;
  };

  /*
    ORIGINAL FRAME
  
    Stores the initial location and size of a view in the "originalFrame" attribute, so you can revert to it later on.
  
    Example:
    The x coordinate of MyView is initially 400 (from the PSD)
    
    ```MyView.x = 200; // now we set it to 200.
    View.x = View.originalFrame.x // now we set it back to its original value, 400.```
  */


  Framer.utils.everyView(function(view) {
    return view.originalFrame = view.frame;
  });

  /*
    SHORTHAND HOVER SYNTAX
  
    Quickly define functions that should run when I hover over a view, and hover out.
  
    Example:
    `MyView.hover(function() { OtherView.show() }, function() { OtherView.hide() });`
  */


  View.prototype.hover = function(enterFunction, leaveFunction) {
    this.on('mouseenter', enterFunction);
    return this.on('mouseleave', leaveFunction);
  };

  /*
    SHORTHAND ANIMATION SYNTAX
  
    A shorter animation syntax that uses the default values `Framer.defaultAnimation.curve` and `Framer.defaultAnimation.time`.
  
    animateTo also sets isAnimating variables on the element depending on whether an animation is in progress. So before starting an animation, you can check if there is already an ongoing one.
  
    Old:
    ```myview.animate({
      properties: {
        x: 500
      },
      time: 500,
      curve: 'ease-in-out'
    })```
  
    New:
    ```myview.animateTo({
      x: 500
    })```
  
    Optionally (with 1000ms duration):
      ```myView.animateTo({
      x: 500
    }, 1000)
  */


  View.prototype.animateTo = function(properties, time) {
    var thisView;

    thisView = this;
    thisView.animationTo = new Animation({
      view: thisView,
      properties: properties,
      curve: Framer.config.defaultAnimation.curve,
      time: Framer.config.defaultAnimation.time
    });
    if (time != null) {
      thisView.animationTo.curve = 'ease-in-out';
      thisView.animationTo.time = time;
    }
    thisView.animationTo.on('start', function() {
      return thisView.isAnimating = true;
    });
    thisView.animationTo.on('end', function() {
      return thisView.isAnimating = null;
    });
    return thisView.animationTo.start();
  };

  /*
    ANIMATE MOBILE VIEWS IN AND OUT OF THE VIEWPORT
  
    Shorthand syntax for animating views in and out of the viewport. Assumes that the view you are animating is a whole screen and has the same dimensions as your container.
  
    To use this, you need to place everything in a parent view called Phone. The library will automatically enable masking and size it to 640 * 1136.
    
    Example:
    * `myView.slideToLeft()` will animate the view **to** the left corner of the screen (from its current position)
  
    * `myView.slideFromLeft()` will animate the view into the viewport **from** the left corner (from x=-width)
  
    Configuration:
    * Framer.config.slideAnimation.time
    * Framer.config.slideAnimation.curve
  
  
    How to read the configuration: 
    ```slideFromLeft:
      property: "x"     // animate along the X axis
      factor: "width"   
      from: -1          // start value: outside the left corner ( x = -width_phone )
      to: 0             // end value: inside the left corner ( x = width_view )
    ```
  */


  _.defer(function() {
    var _phone;

    _phone = Framer.config.displayInDevice.containerView;
    if (_phone != null) {
      _phone.x = 0;
      _phone.y = 0;
      _phone.width = Framer.config.displayInDevice.canvasWidth;
      _phone.height = Framer.config.displayInDevice.canvasHeight;
      return _phone.clip = true;
    }
  });

  Framer.config.slideAnimations = {
    slideFromLeft: {
      property: "x",
      factor: "width",
      from: -1,
      to: 0
    },
    slideToLeft: {
      property: "x",
      factor: "width",
      to: -1
    },
    slideFromRight: {
      property: "x",
      factor: "width",
      from: 1,
      to: 0
    },
    slideToRight: {
      property: "x",
      factor: "width",
      to: 1
    },
    slideFromTop: {
      property: "y",
      factor: "height",
      from: -1,
      to: 0
    },
    slideToTop: {
      property: "y",
      factor: "height",
      to: -1
    },
    slideFromBottom: {
      property: "y",
      factor: "height",
      from: 1,
      to: 0
    },
    slideToBottom: {
      property: "y",
      factor: "height",
      to: 1
    }
  };

  _.each(Framer.config.slideAnimations, function(opts, name) {
    return View.prototype[name] = function() {
      var _animationConfig, _factor, _phone, _property;

      _phone = Framer.config.containerView;
      if (!_phone) {
        console.log("Please wrap your project in a view named Phone, or set Framer.config.containerView to whatever your wrapper view is.");
        return;
      }
      _property = opts.property;
      _factor = _phone[opts.factor];
      if (opts.from != null) {
        this[_property] = opts.from * _factor;
      }
      _animationConfig = {};
      _animationConfig[_property] = opts.to * _factor;
      return this.animate({
        properties: _animationConfig,
        time: Framer.config.slideAnimation.time,
        curve: Framer.config.slideAnimation.curve
      });
    };
  });

  /*
    EASY FADE IN / FADE OUT
  
    .show() and .hide() are shortcuts to affect `myView.visible`. They immediately show or hide the view.
  
    .fadeIn() and .fadeOut() are shortcuts to fade in a hidden view, or fade out a visible view.
  
    To customize the fade animation, change the variables `Framer.config.defaultFadeAnimation.time` and `defaultFadeAnimation.curve`.
  */


  View.prototype.show = function() {
    this.visible = true;
    return this.opacity = 1;
  };

  View.prototype.hide = function() {
    return this.visible = false;
  };

  View.prototype.fadeIn = function(time) {
    if (time == null) {
      time = Framer.config.fadeAnimation.time;
    }
    if (this.opacity === 1 && this.visible) {
      return;
    }
    if (!this.visible) {
      this.opacity = 0;
      this.visible = true;
    }
    return this.animate({
      properties: {
        opacity: 1
      },
      curve: Framer.config.fadeAnimation.curve,
      time: time
    });
  };

  View.prototype.fadeOut = function(time) {
    var that;

    if (time == null) {
      time = Framer.config.fadeAnimation.time;
    }
    if (this.opacity === 0 || !this.visible) {
      return;
    }
    that = this;
    return this.animate({
      properties: {
        opacity: 0
      },
      curve: Framer.config.fadeAnimation.curve,
      time: time,
      callback: function() {
        return that.visible = false;
      }
    });
  };

  /*
    EASY HOVER AND TOUCH/CLICK STATES FOR VIEWS
  
    By naming your view hierarchy in the following way, you can automatically have your views react to hovers, clicks or taps.
  
    Button_touchable
    - Button_default (default state)
    - Button_down (touch/click state)
    - Button_hover (hover)
  */


  Framer.utils.everyView(function(view) {
    var hitTarget, _default, _down, _hover;

    _default = view.getChild('default');
    if (view.name.toLowerCase().indexOf('touchable') && _default) {
      if (!utils.isMobile()) {
        _hover = view.getChild('hover');
      }
      _down = view.getChild('down');
      if (_hover != null) {
        _hover.hide();
      }
      if (_down != null) {
        _down.hide();
      }
      if (_hover || _down) {
        hitTarget = new View({
          frame: _default.frame
        });
        hitTarget.superView = view;
        hitTarget.bringToFront();
      }
      if (_hover) {
        view.hover(function() {
          _default.hide();
          return _hover.show();
        }, function() {
          _default.show();
          return _hover.hide();
        });
      }
      if (_down) {
        view.on(Events.TouchStart, function() {
          _default.hide();
          if (_hover != null) {
            _hover.hide();
          }
          return _down.show();
        });
        return view.on(Events.TouchEnd, function() {
          _down.hide();
          if (_hover) {
            return _hover.show();
          } else {
            return _default.show();
          }
        });
      }
    }
  });

  /*
    DISPLAY IN DEVICE
  
    If you're prototyping a mobile app, showing it in a device can be helpful for presentations.
  
    Wrapping everything in a top level view (group in Sketch/PS) called "Phone" will enable this mode and wrap the view in an iPhone image.
  */


  Device = (function() {
    function Device() {}

    Device.prototype.build = function(args) {
      var _this = this;

      _.extend(this, args);
      if (this.enabled && this.containerView && !utils.isMobile()) {
        this.enableCursor();
        this.backgroundView = new ImageView({
          x: 0,
          y: 0,
          width: window.innerWidth,
          height: window.innerHeight,
          image: this.backgroundImage
        });
        this.backgroundView.name = 'BackgroundView';
        this.backgroundView.style.backgroundColor = 'white';
        this.handView = new ImageView({
          midX: window.innerWidth / 2,
          midY: window.innerHeight / 2,
          width: this.handWidth,
          height: this.handHeight,
          image: this.handImage
        });
        this.handView.name = 'HandView';
        this.handView.style.backgroundColor = 'transparent';
        this.handView.superView = this.backgroundView;
        this.deviceView = new ImageView({
          midX: window.innerWidth / 2,
          midY: window.innerHeight / 2,
          width: this.deviceWidth,
          height: this.deviceHeight,
          image: this.deviceImage
        });
        this.deviceView.name = 'DeviceView';
        window.addEventListener('resize', function() {
          return _this.resize();
        });
        window.addEventListener('keydown', function(e) {
          if (e.keyCode === 32) {
            _this.enabled = !_this.enabled;
            return _this.refresh();
          }
        });
        this.refresh();
        return this.resize();
      }
    };

    Device.prototype.enableCursor = function() {
      return document.body.style.cursor = "url(" + Framer.config.displayInDevice.bobbleImage + ") 32 32, default";
    };

    Device.prototype.refresh = function() {
      if (this.enabled) {
        this.containerView.superView = this.deviceView;
        this.containerView.midX = this.deviceView.width / 2;
        this.containerView.midY = this.deviceView.height / 2;
        this.backgroundView.show();
        return this.deviceView.show();
      } else {
        this.containerView.superView = null;
        this.containerView.x = 0;
        this.containerView.y = 0;
        this.backgroundView.hide();
        return this.deviceView.hide();
      }
    };

    Device.prototype.resize = function() {
      var scaleFactor;

      this.backgroundView.width = window.innerWidth;
      this.backgroundView.height = window.innerHeight;
      this.deviceView.midX = this.handView.midX = window.innerWidth / 2;
      if (this.resizeToFit) {
        scaleFactor = window.innerHeight / this.deviceView.height * 0.95;
        this.deviceView.scale = this.handView.scale = scaleFactor;
      }
      if (this.resizeToFit || window.innerHeight > this.deviceView.height) {
        return this.deviceView.midY = this.handView.midY = window.innerHeight / 2;
      } else {
        this.deviceView.y = this.handView.y = 0;
        return this.backgroundView.height = this.deviceView.height;
      }
    };

    return Device;

  })();

  Framer.Device = new Device;

  _.defer(function() {
    return Framer.Device.build(Framer.config.displayInDevice);
  });

  /*
    SHORTHAND FOR TAP EVENTS
  
    Instead of `view.on(Events.TouchEnd, handler)`, use `view.tap(handler)`
  */


  View.prototype.tap = function(handler) {
    return this.on(Events.TouchEnd, handler);
  };

}).call(this);
